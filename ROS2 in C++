  *ROS2 Basics in 5 days C++ *

Alguns comandos obvios nao serão postos nesse resumo, pois, antes foi feito curso de ros2 em pyhon, que eh semelhante.
launch folder: Contains launch files
src folder: Contains source files (CPP, Python)
CMakeLists.txt: List of Cmake rules for compilation
package.xml: Package metadata and dependencies

    *First package*
dentro do src do workskpace:
ros2 pkg create <package_name> --build-type ament_cmake --dependencies <package_dependencies> 
ros2 pkg create my_package --build-type ament_cmake --dependencies rclcpp  (exemplo)

depois colcon build no ws ou colcon build --packages-select <package_name>
e source install/setup.bash

  *launch*

ao criar um file em python dentro do launch tem que ser <.launch.py> , exemplo: touch my_package_launch_file.launch.py 

ao executar <ros2 launch my_package my_package_launch_file.launch.py> estamos pegando o py dentro do launch dentro do my_package , então, dentro do my_package eh onde o launch esta 

*exemplo de codigo .cpp dentro do src dentro do folder:

#include "rclcpp/rclcpp.hpp"

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared("ObiWan");
  // We create a Rate object of 2Hz
  rclcpp::WallRate loop_rate(2);

  // Endless loop until Ctrl + C
  while (rclcpp::ok()) {

    RCLCPP_INFO(node->get_logger(), "Help me Obi-Wan Kenobi, you're my only hope");
    rclcpp::spin_some(node);
    // We sleep the needed time to maintain the Rate fixed above
    loop_rate.sleep();
        
  }
  rclcpp::shutdown();
  return 0;
}
// This program creates an endless loop that repeats itself 2 times per second (2Hz) until somebody presses Ctrl + C
// in the Shell

*exemplo  do cmakelist dentro do src dentro do folder:

cmake_minimum_required(VERSION 3.8)
project(my_package)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # uncomment the line when a copyright and license is not present in all source files
  #set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # uncomment the line when this package is not in a git repo
  #set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

add_executable(simple_node src/simple.cpp)
ament_target_dependencies(simple_node rclcpp)

install(TARGETS
   simple_node
   DESTINATION lib/${PROJECT_NAME}
 )

install(DIRECTORY
  launch
  DESTINATION share/${PROJECT_NAME}/
)

ament_package()

*Arquivo.py dentro do launch :

from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_package',
            executable='simple_node',
            output='screen'),
    ])

          *RESUMO ESSECENCIAL*

*Estrutura de pastas - Workspace > src > Pasta1(com dependendcia em c++) > src e launch (src - codigos C++ / launch - codigo .launch.py) obs: dentro da pasta dependente criada antes, alem do src e launch 
tem cmake.txt e package.xml , o .txt deve ser alterado adicionando o executavel para rodar o codigo 

*Após executar o launch , um topico foi ativado, se der ros2 topic list | grep '/counter' , vemos que esse foi o topico de exemplo que foi ativado.
ros2 topic info /counter vai dizer quantos publishers e subscriptions foram ativados nesse topic
e ros2 topic echo /counter vai mostrar o output em tempo real doq ta rolando e ros2 interface show std_msgs/msg/Int32 mostra interface

*Ao criar uma nova pasta , deve por no src dentro dela o codigo.cpp e no launch o .py que ira trazer o cpp, alem disso o cmake deve ser editado, exemplo:

linha adicionada no codigo cmake entre o endif() e o ament_package():

add_executable(simple_subscriber_node src/simple_topic_subscriber.cpp)
ament_target_dependencies(simple_subscriber_node rclcpp std_msgs)

install(TARGETS
   simple_subscriber_node
   DESTINATION lib/${PROJECT_NAME}
 )

# Install launch files.
install(DIRECTORY
  launch
  DESTINATION share/${PROJECT_NAME}/
)

Exemplo dessa linha de raciocinio do codigo.launch.py:

from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='topic_subscriber_pkg',
            executable='simple_subscriber_node',
            output='screen'),
    ])


      *Classes em c++/Publisher*

exemplo de codigo :

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/int32.hpp"
#include <chrono>

using namespace std::chrono_literals;

/* This example creates a subclass of Node and uses std::bind() to register a
 * member function as a callback from the timer. */

class SimplePublisher : public rclcpp::Node
{
public:
  SimplePublisher()
  : Node("simple_publisher"), count_(0)
  {
    publisher_ = this->create_publisher<std_msgs::msg::Int32>("counter", 10);
    timer_ = this->create_wall_timer(
      500ms, std::bind(&SimplePublisher::timer_callback, this));
  }

private:
  void timer_callback()
  {
    auto message = std_msgs::msg::Int32();
    message.data = count_;
    count_++;
    publisher_->publish(message);
  }
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr publisher_;
  size_t count_;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<SimplePublisher>());
  rclcpp::shutdown();
  return 0;
}

       *Publisher/Subscriber*

Para publicar uma mensagem especifica em um topic - <ros2 topic pub <topic_name> <message_type> <value>> ex: ros2 topic pub /counter std_msgs/Int32 "{data: '5'}"

exemplo de codigo subscriber q espera um publisher:

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/int32.hpp"
using std::placeholders::_1;

class SimpleSubscriber : public rclcpp::Node
{
public:
  SimpleSubscriber()
  : Node("simple_subscriber")
  {
    subscription_ = this->create_subscription<std_msgs::msg::Int32>(
      "counter", 10, std::bind(&SimpleSubscriber::topic_callback, this, _1));
  }

private:
  void topic_callback(const std_msgs::msg::Int32::SharedPtr msg)
  {
    RCLCPP_INFO(this->get_logger(), "I heard: '%d'", msg->data);
  }
  rclcpp::Subscription<std_msgs::msg::Int32>::SharedPtr subscription_;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<SimpleSubscriber>());
  rclcpp::shutdown();
  return 0;
} 

          *CREATE A CUSTOM INTERFACE*
Exemplo:
1- cria um pkg dependente pra alocar as interfaces - ros2 pkg create --build-type ament_cmake custom_interfaces --dependencies rclcpp std_msgs
2- dentro do pkg cria um folder msg
3-dentro do folder criar um file age.msg
exemplo file.msg:
float32 years
float32 months
float32 days
4-no cmake list adicionar find_package e rosidl_generate_interfaces
ex: 
adiciona isso:
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)
e isso:
rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/Age.msg"
)

*exemplo cmake completo:

cmake_minimum_required(VERSION 3.8)
project(custom_interfaces)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # uncomment the line when a copyright and license is not present in all source files
  #set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # uncomment the line when this package is not in a git repo
  #set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/Age.msg"
)

ament_package()


*Adicionar no .xml:

<build_depend>rosidl_default_generators</build_depend>

<exec_depend>rosidl_default_runtime</exec_depend>

<member_of_group>rosidl_interface_packages</member_of_group>

*.xml completo:
 
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>custom_interfaces</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="user@todo.todo">user</maintainer>
  <license>TODO: License declaration</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>std_msgs</depend>

  <build_depend>rosidl_default_generators</build_depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>

*Esse cmake e .xml foram da propria pasta do custom_interace, mas dentro da pasta que vai rodar o cidgo em .cpp q usara a interface o xml e cmake tbm deve ser alterado!
no .xml eh adicionado:
<depend>custom_interfaces</depend>
e no cmake:
find_package(custom_interfaces REQUIRED) # This is the package that contains the custom interface

add_executable(age_publisher_node src/publish_age.cpp)
ament_target_dependencies(age_publisher_node rclcpp std_msgs custom_interfaces) # Note that we are also adding the package which contains the custom interface as a dependency of the node that will be using this custom interface

install(TARGETS
   age_publisher_node
   DESTINATION lib/${PROJECT_NAME}
 )


                *ABAIXO CODIGO QUE O ROBO ANALISA SE TEM UMA BOLA NA FRENTE E DESVIA *

*.LAUNCH:


from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='topics_quiz',
            executable='topics_quiz_node',
            name='topics_quiz_node',
            output='screen'),
    ])


*.CPP:


#include "rclcpp/rclcpp.hpp"
#include "geometry_msgs/msg/twist.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"
#include <chrono>

using namespace std::chrono_literals;
using std::placeholders::_1;

class TopicsQuiz : public rclcpp::Node
{
public:
  TopicsQuiz()
  : Node("topics_project")
  {
    publisher_ = this->create_publisher<geometry_msgs::msg::Twist>("cmd_vel", 10);
    subscription_ = this->create_subscription<sensor_msgs::msg::LaserScan>(
      "/scan", rclcpp::SensorDataQoS(), std::bind(&TopicsQuiz::scan_callback, this, _1));
    timer_ = this->create_wall_timer(
      500ms, std::bind(&TopicsQuiz::timer_callback, this));
    this->laser_left = 0.0;
    this->laser_right = 0.0;
    this->laser_forward = 0.0;

  }

private:
  geometry_msgs::msg::Twist twist; 

  void scan_callback(const sensor_msgs::msg::LaserScan::SharedPtr msg)
  {

    this->laser_left = msg->ranges[180];
    this->laser_right = msg->ranges[540];
    this->laser_forward = msg->ranges[360];

    RCLCPP_INFO(this->get_logger(), "[LEFT] = '%f'", this->laser_left);
    RCLCPP_INFO(this->get_logger(), "[RIGHT] = '%f'", this->laser_right);
    RCLCPP_INFO(this->get_logger(), "[FORWARD] = '%f'", this->laser_forward);
    
  }

  void timer_callback()
  {
    if (this->laser_forward <= 1.0 || this->laser_right <= 1.0) 
    {
        this->twist_msg.angular.z = 0.3;
        this->twist_msg.linear.x = 0.0;
    }            
    else if (this->laser_left <= 1.0)
    {
        this->twist_msg.angular.z = -0.3;
        this->twist_msg.linear.x = 0.0;
    }
    else
    {
        this->twist_msg.angular.z = 0.0;
        this->twist_msg.linear.x = 0.3;
    }

    publisher_->publish(this->twist_msg);  
  }

  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;
  rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr subscription_;
  geometry_msgs::msg::Twist twist_msg; 
  float laser_left;
  float laser_right;
  float laser_forward;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<TopicsQuiz>());
  rclcpp::shutdown();
  return 0;
}

*CMAKE.TXT:


cmake_minimum_required(VERSION 3.8)
project(topics_quiz)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # uncomment the line when a copyright and license is not present in all source files
  #set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # uncomment the line when this package is not in a git repo
  #set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

add_executable(topics_quiz_node src/topics_quiz.cpp)
ament_target_dependencies(topics_quiz_node rclcpp geometry_msgs sensor_msgs)

install(TARGETS
   topics_quiz_node
   DESTINATION lib/${PROJECT_NAME}
 )

# Install launch files.
install(DIRECTORY
  launch
  DESTINATION share/${PROJECT_NAME}/
)

ament_package()

     *Executor*

adicionar ao codigo:
rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(node);
  executor.spin();

  rclcpp::shutdown();

é o mesmo que adicionar um executor, eh util quando for rodar mais de um no e usar spin() diretamente no nó (rclcpp::spin(node)) ainda funciona, mas o executor dá mais controle e flexibilidade, alem de,
com essa ferramenta, pode executar callbacks e nodes simultaneamente 


    *Types of executors*

The Single-threaded Executor uses one thread to execute all the Node instructions.

The Multi-threaded Executor creates a variable number of threads that allow multiple messages/events to process in parallel.

The Static Single-threaded Executor performs a Node scan only once when the Node is added to the Executor. Therefore, use it only with Nodes that create all related Callbacks during initialization.

obs:Um detalhe importante eh saber que dentro do () do executor eh uma instancia do no,
ou seja, uma variavel que armazena o valor do no.

    *The Single-threaded Executor*

A seguir segue exemplo de codigo com esse executor, ele puxa dois nos ao mesmo tempo para funcionarem simultaneamente. Porem isso n funciona pois ele su possui uma thread

#include <nav_msgs/msg/odometry.hpp>
#include <rclcpp/rclcpp.hpp>
#include <unistd.h>

using namespace std::chrono_literals;

class OdomSubscriber : public rclcpp::Node {
public:
  OdomSubscriber(std::string odom_topic_name) : Node("odom_subscriber") {

    subscription_ = this->create_subscription<nav_msgs::msg::Odometry>(
        odom_topic_name, 10,
        std::bind(&OdomSubscriber::topic_callback, this,
                  std::placeholders::_1));
  }

private:
  void topic_callback(const nav_msgs::msg::Odometry::SharedPtr msg) {
    RCLCPP_INFO(this->get_logger(), "Odometry=['%f','%f','%f']",
                msg->pose.pose.position.x, msg->pose.pose.position.y,
                msg->pose.pose.position.z);
  }
  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr subscription_;
};

class SlowTimer : public rclcpp::Node {
public:
  SlowTimer(float sleep_timer) : Node("slow_timer_subscriber") {
    this->wait_time = sleep_timer;
    timer_ = this->create_wall_timer(
        500ms, std::bind(&SlowTimer::timer_callback, this));
  }

private:
  void timer_callback() {
    sleep(this->wait_time);
    RCLCPP_INFO(this->get_logger(), "TICK");
  }
  rclcpp::TimerBase::SharedPtr timer_;
  float wait_time;
};

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);

  // Instantiate the odometry subscriber node
  std::shared_ptr<OdomSubscriber> odom_subs_node =
      std::make_shared<OdomSubscriber>("/box_bot_1/odom");

  // Instantiate the timer node node
  float sleep_time = 3.0;
  std::shared_ptr<SlowTimer> slow_timer_node =
      std::make_shared<SlowTimer>(sleep_time);

  RCLCPP_INFO(odom_subs_node->get_logger(), "odom_subs_node INFO...");
  RCLCPP_INFO(slow_timer_node->get_logger(), "slow_timer_node INFO...");

  rclcpp::executors::SingleThreadedExecutor executor;
    
  // Add the odometry subscriber node to the executor
  executor.add_node(odom_subs_node);
  // Add the timer node to the executor
  executor.add_node(slow_timer_node);
  executor.spin();

  rclcpp::shutdown();
  return 0;
}


         *Multi-Threaded Executor running two Nodes*
nesse exmplo a seguir os callbacks nao interferem um no outro e são executados simultaneamente:

#include <nav_msgs/msg/odometry.hpp>
#include <rclcpp/rclcpp.hpp>
#include <unistd.h>

// For the parameters, templates of seconds or ms
using namespace std::chrono_literals;

class OdomSubscriber : public rclcpp::Node {
public:
  OdomSubscriber(std::string odom_topic_name) : Node("odom_subscriber") {

    subscription_ = this->create_subscription<nav_msgs::msg::Odometry>(
        odom_topic_name, 10,
        std::bind(&OdomSubscriber::topic_callback, this,
                  std::placeholders::_1));
  }

private:
  void topic_callback(const nav_msgs::msg::Odometry::SharedPtr msg) {
    RCLCPP_INFO(this->get_logger(), "Odometry=['%f','%f','%f']",
                msg->pose.pose.position.x, msg->pose.pose.position.y,
                msg->pose.pose.position.z);
  }
  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr subscription_;
};

class SlowTimer : public rclcpp::Node {
public:
  SlowTimer(float sleep_timer) : Node("slow_timer_subscriber") {
    this->wait_time = sleep_timer;
    timer_ = this->create_wall_timer(
        500ms, std::bind(&SlowTimer::timer_callback, this));
  }

private:
  void timer_callback() {
    sleep(this->wait_time);
    RCLCPP_INFO(this->get_logger(), "TICK");
  }
  rclcpp::TimerBase::SharedPtr timer_;
  float wait_time;
};

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);

  // Instantiate the odometry subscriber node
  std::shared_ptr<OdomSubscriber> odom_subs_node =
      std::make_shared<OdomSubscriber>("/box_bot_1/odom");

  // Instantiate the timer node node
  float sleep_time = 3.0;
  std::shared_ptr<SlowTimer> slow_timer_node =
      std::make_shared<SlowTimer>(sleep_time);

  RCLCPP_INFO(odom_subs_node->get_logger(), "odom_subs_node INFO...");
  RCLCPP_INFO(slow_timer_node->get_logger(), "slow_timer_node INFO...");

  rclcpp::executors::MultiThreadedExecutor executor;

  // Add the odometry subscriber node to the executor
  executor.add_node(odom_subs_node);
  // Add the timer node to the executor
  executor.add_node(slow_timer_node);
  executor.spin();

  rclcpp::shutdown();
  return 0;
}

Observação: So pode ser executado um executor por codigo, ou seja se vc precisa de dois nos funcionando simultaneamente use o multithreaded executors, se nao seria necessario criar dois programas
em ros2 com o singlethreadedexecutors.

Observação 2: Mesmo o multithreaded executors não consegue por meio de um no q possui 2 calbbacks executar os 2 , apenas o primeiro callback desse no seria executado, nesse caso deve-se criar 
callback groups types


          *CALLBACK GROUP TYPES*

Reentrante: Todos os Callbacks nesses grupos podem ser executados simultaneamente, sem restrições. O Executor criará quantas threads forem necessárias para isso.

Mutuamente Exclusivo: Todos os Callbacks nesses grupos podem ser executados um de cada vez. Isso é útil para Callbacks que, por algum motivo, afetam o mesmo sistema ou 
utilizam os mesmos recursos que outros. Além disso, esse tipo de Callback oferece um melhor controle sobre o fluxo de execução dos Callbacks.

        *Reentrant Callback Groups*
*Aparentemente faz com que os callbacks sejam executados ao mesmo tempo pela mesma intancia de no, exemplo:

#include <rclcpp/rclcpp.hpp>
#include <unistd.h>

using namespace std::chrono_literals;

class TwoTimer : public rclcpp::Node {
public:
  TwoTimer(float sleep_timer1, float sleep_timer2)
      : Node("slow_timer_subscriber") {
          
    // Initialize one Reentrant callback group object
    callback_group_ =
        this->create_callback_group(rclcpp::CallbackGroupType::Reentrant);

    this->wait_time1 = sleep_timer1;
    this->wait_time2 = sleep_timer2;

    timer1_ = this->create_wall_timer(
        500ms, std::bind(&TwoTimer::timer1_callback, this), callback_group_);
    timer2_ = this->create_wall_timer(
        500ms, std::bind(&TwoTimer::timer2_callback, this), callback_group_);
  }

private:
  void timer1_callback() {
    RCLCPP_INFO(this->get_logger(), "Timer 1 Callback Start");
    sleep(this->wait_time1);
    RCLCPP_INFO(this->get_logger(), "Timer 1 Callback End");
  }

  void timer2_callback() {
    RCLCPP_INFO(this->get_logger(), "Timer 2 Callback Start");
    sleep(this->wait_time2);
    RCLCPP_INFO(this->get_logger(), "Timer 2 Callback End");
  }

  rclcpp::CallbackGroup::SharedPtr callback_group_;
  rclcpp::TimerBase::SharedPtr timer1_;
  rclcpp::TimerBase::SharedPtr timer2_;
  float wait_time1;
  float wait_time2;
};

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);

  // Instantiate the Node
  float sleep_time1 = 1.0;
  float sleep_time2 = 3.0;
  std::shared_ptr<TwoTimer> two_timer_node =
      std::make_shared<TwoTimer>(sleep_time1, sleep_time2);

  // Initialize one MultiThreadedExecutor object
  rclcpp::executors::MultiThreadedExecutor executor;
  executor.add_node(two_timer_node);
  executor.spin();

  rclcpp::shutdown();
  return 0;
}

               *Single MutuallyExclusive Example*
*Esse aq vai dar aquele erro, ele n vai executar os 2 callbacks simultaneamente pois nao se trata de um reentrant

#include <rclcpp/rclcpp.hpp>
#include <unistd.h>

using namespace std::chrono_literals;

class TwoTimer : public rclcpp::Node {
public:
  TwoTimer(float sleep_timer1, float sleep_timer2)
      : Node("slow_timer_subscriber") {

    // Initialize one MutuallyExclusive callback group object
    callback_group_ = this->create_callback_group(
        rclcpp::CallbackGroupType::MutuallyExclusive);

    this->wait_time1 = sleep_timer1;
    this->wait_time2 = sleep_timer2;

    timer1_ = this->create_wall_timer(
        500ms, std::bind(&TwoTimer::timer1_callback, this), callback_group_);
    timer2_ = this->create_wall_timer(
        500ms, std::bind(&TwoTimer::timer2_callback, this), callback_group_);
  }

private:
  void timer1_callback() {
    RCLCPP_INFO(this->get_logger(), "Timer 1 Callback Start");
    sleep(this->wait_time1);
    RCLCPP_INFO(this->get_logger(), "Timer 1 Callback End");
  }

  void timer2_callback() {
    RCLCPP_INFO(this->get_logger(), "Timer 2 Callback Start");
    sleep(this->wait_time2);
    RCLCPP_INFO(this->get_logger(), "Timer 2 Callback End");
  }

  rclcpp::CallbackGroup::SharedPtr callback_group_;
  rclcpp::TimerBase::SharedPtr timer1_;
  rclcpp::TimerBase::SharedPtr timer2_;
  float wait_time1;
  float wait_time2;
};

int main(int argc, char *argv[]) {

  rclcpp::init(argc, argv);

  // Instantiate the Node
  float sleep_time1 = 1.0;
  float sleep_time2 = 3.0;
  std::shared_ptr<TwoTimer> two_timer_node =
      std::make_shared<TwoTimer>(sleep_time1, sleep_time2);

  // Initialize one MultiThreadedExecutor object
  rclcpp::executors::MultiThreadedExecutor executor;
  executor.add_node(two_timer_node);
  executor.spin();

  rclcpp::shutdown();
  return 0;
}

       *Multiple MutuallyExclusive Example*
Aq resolve o problema do anterior pois usou mutuallyexlusive callbacks separados para cada grupo
#include <rclcpp/rclcpp.hpp>
#include <unistd.h>

using namespace std::chrono_literals;

class TwoTimer : public rclcpp::Node {
public:
  TwoTimer(float sleep_timer1, float sleep_timer2)
      : Node("slow_timer_subscriber") {

    callback_group_1 = this->create_callback_group(
        rclcpp::CallbackGroupType::MutuallyExclusive);
    callback_group_2 = this->create_callback_group(
        rclcpp::CallbackGroupType::MutuallyExclusive);

    this->wait_time1 = sleep_timer1;
    this->wait_time2 = sleep_timer2;

    timer1_ = this->create_wall_timer(
        500ms, std::bind(&TwoTimer::timer1_callback, this), callback_group_1);
    timer2_ = this->create_wall_timer(
        500ms, std::bind(&TwoTimer::timer2_callback, this), callback_group_2);
  }

private:
  void timer1_callback() {
    RCLCPP_INFO(this->get_logger(), "Timer 1 Callback Start");
    sleep(this->wait_time1);
    RCLCPP_INFO(this->get_logger(), "Timer 1 Callback End");
  }

  void timer2_callback() {
    RCLCPP_INFO(this->get_logger(), "Timer 2 Callback Start");
    sleep(this->wait_time2);
    RCLCPP_INFO(this->get_logger(), "Timer 2 Callback End");
  }

  rclcpp::CallbackGroup::SharedPtr callback_group_1;
  rclcpp::CallbackGroup::SharedPtr callback_group_2;
  rclcpp::TimerBase::SharedPtr timer1_;
  rclcpp::TimerBase::SharedPtr timer2_;
  float wait_time1;
  float wait_time2;
};

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);

  // Instantiate the Node
  float sleep_time1 = 1.0;
  float sleep_time2 = 3.0;
  std::shared_ptr<TwoTimer> two_timer_node =
      std::make_shared<TwoTimer>(sleep_time1, sleep_time2);

  // Initialize one MultiThreadedExecutor object
  rclcpp::executors::MultiThreadedExecutor executor;
  executor.add_node(two_timer_node);
  executor.spin();

  rclcpp::shutdown();
  return 0;
}

   *SERVICES*
ros2 service list - lista os services que possui
ros2 service call <service_name> <service_type> <value> - pra realmente chamar um comando service, como pode ver tem um service type, pra isso vc tem q executar outro comando pra saber o type
ros2 service type <service q tem no service list> - ai com o output pode usar o service call

*no codigo abaixo, n foi necessario usar service call, pois, dentro do codigo ja ocorreu toda a logica de chamar o service e criar um client:

#include "rclcpp/rclcpp.hpp"
#include "std_srvs/srv/empty.hpp"

#include <chrono>
#include <cstdlib>
#include <memory>

using namespace std::chrono_literals;

int main(int argc, char **argv)
{
  rclcpp::init(argc, argv);

  std::shared_ptr<rclcpp::Node> node = rclcpp::Node::make_shared("service_client");
  rclcpp::Client<std_srvs::srv::Empty>::SharedPtr client =
    node->create_client<std_srvs::srv::Empty>("moving");

  auto request = std::make_shared<std_srvs::srv::Empty::Request>();

  while (!client->wait_for_service(1s)) {
    if (!rclcpp::ok()) {
      RCLCPP_ERROR(rclcpp::get_logger("rclcpp"), "Interrupted while waiting for the service. Exiting.");
      return 0;
    }
    RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "service not available, waiting again...");
  }

  auto result_future = client->async_send_request(request);
  // Wait for the result.
  if (rclcpp::spin_until_future_complete(node, result_future) ==
    rclcpp::FutureReturnCode::SUCCESS)
  {
    auto result = result_future.get();
    RCLCPP_INFO(rclcpp::get_logger("rclcpp"), "The robot is moving");
  } else {
    RCLCPP_ERROR(rclcpp::get_logger("rclcpp"), "Failed to call service /moving");
  }

  rclcpp::shutdown();
  return 0;
}


    *CUSTOM SERVICE INTERFACE*

Dentro do pacote /src/custom_interfaces cria um mkdir srv e dentro dele um touch example.srv, la vc bota a interface desejada e edita o cmake e o .xml
.dentro do cmake . apos o endif:
rosidl_generate_interfaces(${PROJECT_NAME}
  "srv/example.srv"
)

.xml:
<build_depend>rosidl_default_generators</build_depend>

<exec_depend>rosidl_default_runtime</exec_depend>

<member_of_group>rosidl_interface_packages</member_of_group>

.Depois de editado e compilado+source , basta dar ros2 interface show custom_interfaces/srv/example
.apos isso tem q criar um codigo que siga a logica doq botou na interface, exemplo:
interface:
string move   # Signal to define the movement
              # "Turn right" to make the robot turn in the right direction.
              # "Turn left" to make the robot turn in the left direction. 
              # "Stop" to make the robot stop the movement.

---
bool success  # Did it achieve it?

codigo em c++ q usa essa interface : 
#include "rclcpp/rclcpp.hpp"
#include "custom_interfaces/srv/my_custom_service_message.hpp"
#include "geometry_msgs/msg/twist.hpp"

#include <memory>

using MyCustomServiceMessage = custom_interfaces::srv::MyCustomServiceMessage;
using std::placeholders::_1;
using std::placeholders::_2;

class ServerNode : public rclcpp::Node
{
public:
  ServerNode()
  : Node("movement_server")
  {

    srv_ = create_service<MyCustomServiceMessage>("movement", std::bind(&ServerNode::moving_callback, this, _1, _2));
    publisher_ = this->create_publisher<geometry_msgs::msg::Twist>("cmd_vel", 10);

  }

private:
  rclcpp::Service<MyCustomServiceMessage>::SharedPtr srv_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;

  void moving_callback(
      const std::shared_ptr<MyCustomServiceMessage::Request> request,
      const std::shared_ptr<MyCustomServiceMessage::Response>
          response) 
    {

        auto message = geometry_msgs::msg::Twist();
    
        if (request->move == "Turn Right")
        {   
            // Send velocities to move the robot to the right
            message.linear.x = 0.2;
            message.angular.z = -0.2;
            publisher_->publish(message);

            // Set the response success variable to true
            response->success = true;
        }
        else if (request->move == "Turn Left")
        {
            // Send velocities to stop the robot
            message.linear.x = 0.2;
            message.angular.z = 0.2;
            publisher_->publish(message);

            // Set the response success variable to false
            response->success = true;
        }
        else if (request->move == "Stop")
        {
            // Send velocities to stop the robot
            message.linear.x = 0.0;
            message.angular.z = 0.0;
            publisher_->publish(message);

            // Set the response success variable to false
            response->success = true;
        }
        else {
            response->success = false;
        }
                
    }
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<ServerNode>());
  rclcpp::shutdown();
  return 0;
}

     *ACTION* (goal ,result and feedback)

.Parecidos com services, a diferença eh q action pode ser cancelado enquanto executado e eles dão feedbacks ao client em tempo real
.Action usa services to handle the goal and result e topic para feedback
The node that provides the Action functionality has to contain an Action Server. The Action Server allows other nodes to call that Action functionality.
The node that calls to the Action functionality has to contain an Action Client. The Action Client allows a node to connect to the Action Server of another node.
ou seja,
In summary, the workflow goes like this:

The Client sends a goal to the Server. This will trigger the "start" of the Action.
The Server sends feedback to the Client meanwhile the Action is taking place.
Once the Action finishes, the Server returns a response to the Client.

.ros2 action info </move_robot_as> -t    -This output, which may seem somewhat strange at first reading, tells us that the /move_robot_as Action uses the interface t3_action_msg/action/Move.
<package_name>/action/<interface_name>

.ros2 action send_goal <action_name> <action_type> <values> e ros2 action send_goal  -f <action_name> <action_type> <values> (pra trazer feedback junto)
example: ros2 action send_goal /move_robot_as t3_action_msg/action/Move "{secs: 5}"

Codigo action client onde o client manda uma solicitação pro servidor e espera seu output:

#include <inttypes.h>
#include <memory>
#include <string>
#include <iostream>

#include "t3_action_msg/action/move.hpp"
#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"

class MyActionClient : public rclcpp::Node
{
public:
  using Move = t3_action_msg::action::Move;
  using GoalHandleMove = rclcpp_action::ClientGoalHandle<Move>;

  explicit MyActionClient(const rclcpp::NodeOptions & node_options = rclcpp::NodeOptions())
  : Node("my_action_client", node_options), goal_done_(false)
  {
    this->client_ptr_ = rclcpp_action::create_client<Move>(
      this->get_node_base_interface(),
      this->get_node_graph_interface(),
      this->get_node_logging_interface(),
      this->get_node_waitables_interface(),
      "move_robot_as");

    this->timer_ = this->create_wall_timer(
      std::chrono::milliseconds(500),
      std::bind(&MyActionClient::send_goal, this));
  }

  bool is_goal_done() const
  {
    return this->goal_done_;
  }

  void send_goal()
  {
    using namespace std::placeholders;

    this->timer_->cancel();

    this->goal_done_ = false;

    if (!this->client_ptr_) {
      RCLCPP_ERROR(this->get_logger(), "Action client not initialized");
    }

    if (!this->client_ptr_->wait_for_action_server(std::chrono::seconds(10))) {
      RCLCPP_ERROR(this->get_logger(), "Action server not available after waiting");
      this->goal_done_ = true;
      return;
    }

    auto goal_msg = Move::Goal();
    goal_msg.secs = 5;

    RCLCPP_INFO(this->get_logger(), "Sending goal");

    auto send_goal_options = rclcpp_action::Client<Move>::SendGoalOptions();
                
    send_goal_options.goal_response_callback =
      std::bind(&MyActionClient::goal_response_callback, this, _1);

    send_goal_options.feedback_callback =
      std::bind(&MyActionClient::feedback_callback, this, _1, _2);

    send_goal_options.result_callback =
      std::bind(&MyActionClient::result_callback, this, _1);
      
    auto goal_handle_future = this->client_ptr_->async_send_goal(goal_msg, send_goal_options);
  }

private:
  rclcpp_action::Client<Move>::SharedPtr client_ptr_;
  rclcpp::TimerBase::SharedPtr timer_;
  bool goal_done_;

  void goal_response_callback(const GoalHandleMove::SharedPtr & goal_handle)
  {
    if (!goal_handle) {
      RCLCPP_ERROR(this->get_logger(), "Goal was rejected by server");
    } else {
      RCLCPP_INFO(this->get_logger(), "Goal accepted by server, waiting for result");
    }
  }

  void feedback_callback(
    GoalHandleMove::SharedPtr,
    const std::shared_ptr<const Move::Feedback> feedback)
  {
    RCLCPP_INFO(
      this->get_logger(), "Feedback received: %s", feedback->feedback.c_str());
  }

  void result_callback(const GoalHandleMove::WrappedResult & result)
  {
    this->goal_done_ = true;
    switch (result.code) {
      case rclcpp_action::ResultCode::SUCCEEDED:
        break;
      case rclcpp_action::ResultCode::ABORTED:
        RCLCPP_ERROR(this->get_logger(), "Goal was aborted");
        return;
      case rclcpp_action::ResultCode::CANCELED:
        RCLCPP_ERROR(this->get_logger(), "Goal was canceled");
        return;
      default:
        RCLCPP_ERROR(this->get_logger(), "Unknown result code");
        return;
    }

    RCLCPP_INFO(this->get_logger(), "Result received: %s", result.result->status.c_str());

  }
};  // class MyActionClient

int main(int argc, char ** argv)
{
  rclcpp::init(argc, argv);
  auto action_client = std::make_shared<MyActionClient>();
    
  rclcpp::executors::MultiThreadedExecutor executor;
  executor.add_node(action_client);

  while (!action_client->is_goal_done()) {
    executor.spin_some();
  }

  rclcpp::shutdown();
  return 0;
}

abaixo o action server que em outro exemplo foi executado junto ao codigo anterior em outro terminal
obs:codigo anterior teve q mudar o nome do node para executar o server e client juntos

#include <functional>
#include <memory>
#include <thread>

#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"

#include "t3_action_msg/action/move.hpp"
#include "geometry_msgs/msg/twist.hpp"


class MyActionServer : public rclcpp::Node
{
public:
  using Move = t3_action_msg::action::Move;
  using GoalHandleMove = rclcpp_action::ServerGoalHandle<Move>;

  explicit MyActionServer(const rclcpp::NodeOptions & options = rclcpp::NodeOptions())
  : Node("my_action_server", options)
  {
    using namespace std::placeholders;

    this->action_server_ = rclcpp_action::create_server<Move>(
      this,
      "move_robot_as_2",
      std::bind(&MyActionServer::handle_goal, this, _1, _2),
      std::bind(&MyActionServer::handle_cancel, this, _1),
      std::bind(&MyActionServer::handle_accepted, this, _1));

    publisher_ = this->create_publisher<geometry_msgs::msg::Twist>("cmd_vel", 10);

  }

private:
  rclcpp_action::Server<Move>::SharedPtr action_server_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;

  rclcpp_action::GoalResponse handle_goal(
    const rclcpp_action::GoalUUID & uuid,
    std::shared_ptr<const Move::Goal> goal)
  {
    RCLCPP_INFO(this->get_logger(), "Received goal request with secs %d", goal->secs);
    (void)uuid;
    return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
  }

  rclcpp_action::CancelResponse handle_cancel(
    const std::shared_ptr<GoalHandleMove> goal_handle)
  {
    RCLCPP_INFO(this->get_logger(), "Received request to cancel goal");
    (void)goal_handle;
    return rclcpp_action::CancelResponse::ACCEPT;
  }

  void handle_accepted(const std::shared_ptr<GoalHandleMove> goal_handle)
  {
    using namespace std::placeholders;
    // this needs to return quickly to avoid blocking the executor, so spin up a new thread
    std::thread{std::bind(&MyActionServer::execute, this, _1), goal_handle}.detach();
  }

  void execute(const std::shared_ptr<GoalHandleMove> goal_handle)
  {
    RCLCPP_INFO(this->get_logger(), "Executing goal");
    const auto goal = goal_handle->get_goal();
    auto feedback = std::make_shared<Move::Feedback>();
    auto & message = feedback->feedback;
    message = "Starting movement...";
    auto result = std::make_shared<Move::Result>();
    auto move = geometry_msgs::msg::Twist();
    rclcpp::Rate loop_rate(1);

    for (int i = 0; (i < goal->secs) && rclcpp::ok(); ++i) {
      // Check if there is a cancel request
      if (goal_handle->is_canceling()) {
        result->status = message;
        goal_handle->canceled(result);
        RCLCPP_INFO(this->get_logger(), "Goal canceled");
        return;
      }
      // Move robot forward and send feedback
      message = "Moving forward...";
      move.linear.x = 0.3;
      publisher_->publish(move);
      goal_handle->publish_feedback(feedback);
      RCLCPP_INFO(this->get_logger(), "Publish feedback");

      loop_rate.sleep();
    }

    // Check if goal is done
    if (rclcpp::ok()) {
      result->status = "Finished action server. Robot moved during 5 seconds";
      move.linear.x = 0.0;
      publisher_->publish(move);
      goal_handle->succeed(result);
      RCLCPP_INFO(this->get_logger(), "Goal succeeded");
    }
  }
};  // class MyActionServer

int main(int argc, char ** argv)
{
  rclcpp::init(argc, argv);

  auto action_server = std::make_shared<MyActionServer>();
    
  rclcpp::executors::MultiThreadedExecutor executor;
  executor.add_node(action_server);
  executor.spin();

  rclcpp::shutdown();
  return 0;
}

  *RVIZ*

rviz2 no terminal abre uma interface que da pra controlar os topicos, bom dar uma testada e olhada nisso durante os testes pra ver como funciona

  *ROS2 Doctor*
This powerful tool reviews the total ROS2 setup from the platform, versions, network, environment, etc. In addition to giving you a proper diagnosis with precautions, 
errors, and possible reasons for problems.
<ros2 doctor --report>
You will see that the report is categorized into 7 sections:

NETWORK CONFIGURATION
PACKAGE VERSION
PLATFORM CONFIGURATION
QOS COMPATIBILITY LIST
RMW MIDDLEWARE
ROS 2 INFORMATION
TOPIC LIST








